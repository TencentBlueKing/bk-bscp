// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/TencentBlueKing/bk-bscp/pkg/dal/table"
)

func newDataSourceMapping(db *gorm.DB, opts ...gen.DOOption) dataSourceMapping {
	_dataSourceMapping := dataSourceMapping{}

	_dataSourceMapping.dataSourceMappingDo.UseDB(db, opts...)
	_dataSourceMapping.dataSourceMappingDo.UseModel(&table.DataSourceMapping{})

	tableName := _dataSourceMapping.dataSourceMappingDo.TableName()
	_dataSourceMapping.ALL = field.NewAsterisk(tableName)
	_dataSourceMapping.ID = field.NewUint32(tableName, "id")
	_dataSourceMapping.BizID = field.NewUint32(tableName, "biz_id")
	_dataSourceMapping.DataSourceInfoID = field.NewUint32(tableName, "data_source_info_id")
	_dataSourceMapping.DatabasesName = field.NewString(tableName, "databases_name")
	_dataSourceMapping.TableName_ = field.NewString(tableName, "table_name")
	_dataSourceMapping.TableMemo = field.NewString(tableName, "table_memo")
	_dataSourceMapping.VisibleRange = field.NewField(tableName, "visible_range")
	_dataSourceMapping.Columns_ = field.NewField(tableName, "columns")
	_dataSourceMapping.Creator = field.NewString(tableName, "creator")
	_dataSourceMapping.Reviser = field.NewString(tableName, "reviser")
	_dataSourceMapping.CreatedAt = field.NewTime(tableName, "created_at")
	_dataSourceMapping.UpdatedAt = field.NewTime(tableName, "updated_at")

	_dataSourceMapping.fillFieldMap()

	return _dataSourceMapping
}

type dataSourceMapping struct {
	dataSourceMappingDo dataSourceMappingDo

	ALL              field.Asterisk
	ID               field.Uint32
	BizID            field.Uint32
	DataSourceInfoID field.Uint32
	DatabasesName    field.String
	TableName_       field.String
	TableMemo        field.String
	VisibleRange     field.Field
	Columns_         field.Field
	Creator          field.String
	Reviser          field.String
	CreatedAt        field.Time
	UpdatedAt        field.Time

	fieldMap map[string]field.Expr
}

func (d dataSourceMapping) Table(newTableName string) *dataSourceMapping {
	d.dataSourceMappingDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d dataSourceMapping) As(alias string) *dataSourceMapping {
	d.dataSourceMappingDo.DO = *(d.dataSourceMappingDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *dataSourceMapping) updateTableName(table string) *dataSourceMapping {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewUint32(table, "id")
	d.BizID = field.NewUint32(table, "biz_id")
	d.DataSourceInfoID = field.NewUint32(table, "data_source_info_id")
	d.DatabasesName = field.NewString(table, "databases_name")
	d.TableName_ = field.NewString(table, "table_name")
	d.TableMemo = field.NewString(table, "table_memo")
	d.VisibleRange = field.NewField(table, "visible_range")
	d.Columns_ = field.NewField(table, "columns")
	d.Creator = field.NewString(table, "creator")
	d.Reviser = field.NewString(table, "reviser")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")

	d.fillFieldMap()

	return d
}

func (d *dataSourceMapping) WithContext(ctx context.Context) IDataSourceMappingDo {
	return d.dataSourceMappingDo.WithContext(ctx)
}

func (d dataSourceMapping) TableName() string { return d.dataSourceMappingDo.TableName() }

func (d dataSourceMapping) Alias() string { return d.dataSourceMappingDo.Alias() }

func (d dataSourceMapping) Columns(cols ...field.Expr) gen.Columns {
	return d.dataSourceMappingDo.Columns(cols...)
}

func (d *dataSourceMapping) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *dataSourceMapping) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 12)
	d.fieldMap["id"] = d.ID
	d.fieldMap["biz_id"] = d.BizID
	d.fieldMap["data_source_info_id"] = d.DataSourceInfoID
	d.fieldMap["databases_name"] = d.DatabasesName
	d.fieldMap["table_name"] = d.TableName_
	d.fieldMap["table_memo"] = d.TableMemo
	d.fieldMap["visible_range"] = d.VisibleRange
	d.fieldMap["columns"] = d.Columns_
	d.fieldMap["creator"] = d.Creator
	d.fieldMap["reviser"] = d.Reviser
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
}

func (d dataSourceMapping) clone(db *gorm.DB) dataSourceMapping {
	d.dataSourceMappingDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d dataSourceMapping) replaceDB(db *gorm.DB) dataSourceMapping {
	d.dataSourceMappingDo.ReplaceDB(db)
	return d
}

type dataSourceMappingDo struct{ gen.DO }

type IDataSourceMappingDo interface {
	gen.SubQuery
	Debug() IDataSourceMappingDo
	WithContext(ctx context.Context) IDataSourceMappingDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDataSourceMappingDo
	WriteDB() IDataSourceMappingDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDataSourceMappingDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDataSourceMappingDo
	Not(conds ...gen.Condition) IDataSourceMappingDo
	Or(conds ...gen.Condition) IDataSourceMappingDo
	Select(conds ...field.Expr) IDataSourceMappingDo
	Where(conds ...gen.Condition) IDataSourceMappingDo
	Order(conds ...field.Expr) IDataSourceMappingDo
	Distinct(cols ...field.Expr) IDataSourceMappingDo
	Omit(cols ...field.Expr) IDataSourceMappingDo
	Join(table schema.Tabler, on ...field.Expr) IDataSourceMappingDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDataSourceMappingDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDataSourceMappingDo
	Group(cols ...field.Expr) IDataSourceMappingDo
	Having(conds ...gen.Condition) IDataSourceMappingDo
	Limit(limit int) IDataSourceMappingDo
	Offset(offset int) IDataSourceMappingDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDataSourceMappingDo
	Unscoped() IDataSourceMappingDo
	Create(values ...*table.DataSourceMapping) error
	CreateInBatches(values []*table.DataSourceMapping, batchSize int) error
	Save(values ...*table.DataSourceMapping) error
	First() (*table.DataSourceMapping, error)
	Take() (*table.DataSourceMapping, error)
	Last() (*table.DataSourceMapping, error)
	Find() ([]*table.DataSourceMapping, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*table.DataSourceMapping, err error)
	FindInBatches(result *[]*table.DataSourceMapping, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*table.DataSourceMapping) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDataSourceMappingDo
	Assign(attrs ...field.AssignExpr) IDataSourceMappingDo
	Joins(fields ...field.RelationField) IDataSourceMappingDo
	Preload(fields ...field.RelationField) IDataSourceMappingDo
	FirstOrInit() (*table.DataSourceMapping, error)
	FirstOrCreate() (*table.DataSourceMapping, error)
	FindByPage(offset int, limit int) (result []*table.DataSourceMapping, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDataSourceMappingDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d dataSourceMappingDo) Debug() IDataSourceMappingDo {
	return d.withDO(d.DO.Debug())
}

func (d dataSourceMappingDo) WithContext(ctx context.Context) IDataSourceMappingDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d dataSourceMappingDo) ReadDB() IDataSourceMappingDo {
	return d.Clauses(dbresolver.Read)
}

func (d dataSourceMappingDo) WriteDB() IDataSourceMappingDo {
	return d.Clauses(dbresolver.Write)
}

func (d dataSourceMappingDo) Session(config *gorm.Session) IDataSourceMappingDo {
	return d.withDO(d.DO.Session(config))
}

func (d dataSourceMappingDo) Clauses(conds ...clause.Expression) IDataSourceMappingDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d dataSourceMappingDo) Returning(value interface{}, columns ...string) IDataSourceMappingDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d dataSourceMappingDo) Not(conds ...gen.Condition) IDataSourceMappingDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d dataSourceMappingDo) Or(conds ...gen.Condition) IDataSourceMappingDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d dataSourceMappingDo) Select(conds ...field.Expr) IDataSourceMappingDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d dataSourceMappingDo) Where(conds ...gen.Condition) IDataSourceMappingDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d dataSourceMappingDo) Order(conds ...field.Expr) IDataSourceMappingDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d dataSourceMappingDo) Distinct(cols ...field.Expr) IDataSourceMappingDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d dataSourceMappingDo) Omit(cols ...field.Expr) IDataSourceMappingDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d dataSourceMappingDo) Join(table schema.Tabler, on ...field.Expr) IDataSourceMappingDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d dataSourceMappingDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDataSourceMappingDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d dataSourceMappingDo) RightJoin(table schema.Tabler, on ...field.Expr) IDataSourceMappingDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d dataSourceMappingDo) Group(cols ...field.Expr) IDataSourceMappingDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d dataSourceMappingDo) Having(conds ...gen.Condition) IDataSourceMappingDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d dataSourceMappingDo) Limit(limit int) IDataSourceMappingDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d dataSourceMappingDo) Offset(offset int) IDataSourceMappingDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d dataSourceMappingDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDataSourceMappingDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d dataSourceMappingDo) Unscoped() IDataSourceMappingDo {
	return d.withDO(d.DO.Unscoped())
}

func (d dataSourceMappingDo) Create(values ...*table.DataSourceMapping) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d dataSourceMappingDo) CreateInBatches(values []*table.DataSourceMapping, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d dataSourceMappingDo) Save(values ...*table.DataSourceMapping) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d dataSourceMappingDo) First() (*table.DataSourceMapping, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*table.DataSourceMapping), nil
	}
}

func (d dataSourceMappingDo) Take() (*table.DataSourceMapping, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*table.DataSourceMapping), nil
	}
}

func (d dataSourceMappingDo) Last() (*table.DataSourceMapping, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*table.DataSourceMapping), nil
	}
}

func (d dataSourceMappingDo) Find() ([]*table.DataSourceMapping, error) {
	result, err := d.DO.Find()
	return result.([]*table.DataSourceMapping), err
}

func (d dataSourceMappingDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*table.DataSourceMapping, err error) {
	buf := make([]*table.DataSourceMapping, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d dataSourceMappingDo) FindInBatches(result *[]*table.DataSourceMapping, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d dataSourceMappingDo) Attrs(attrs ...field.AssignExpr) IDataSourceMappingDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d dataSourceMappingDo) Assign(attrs ...field.AssignExpr) IDataSourceMappingDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d dataSourceMappingDo) Joins(fields ...field.RelationField) IDataSourceMappingDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d dataSourceMappingDo) Preload(fields ...field.RelationField) IDataSourceMappingDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d dataSourceMappingDo) FirstOrInit() (*table.DataSourceMapping, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*table.DataSourceMapping), nil
	}
}

func (d dataSourceMappingDo) FirstOrCreate() (*table.DataSourceMapping, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*table.DataSourceMapping), nil
	}
}

func (d dataSourceMappingDo) FindByPage(offset int, limit int) (result []*table.DataSourceMapping, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d dataSourceMappingDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d dataSourceMappingDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d dataSourceMappingDo) Delete(models ...*table.DataSourceMapping) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *dataSourceMappingDo) withDO(do gen.Dao) *dataSourceMappingDo {
	d.DO = *do.(*gen.DO)
	return d
}
