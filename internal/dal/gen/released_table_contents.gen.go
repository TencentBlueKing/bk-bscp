// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/TencentBlueKing/bk-bscp/pkg/dal/table"
)

func newReleasedTableContent(db *gorm.DB, opts ...gen.DOOption) releasedTableContent {
	_releasedTableContent := releasedTableContent{}

	_releasedTableContent.releasedTableContentDo.UseDB(db, opts...)
	_releasedTableContent.releasedTableContentDo.UseModel(&table.ReleasedTableContent{})

	tableName := _releasedTableContent.releasedTableContentDo.TableName()
	_releasedTableContent.ALL = field.NewAsterisk(tableName)
	_releasedTableContent.ID = field.NewUint32(tableName, "id")
	_releasedTableContent.BizID = field.NewUint32(tableName, "biz_id")
	_releasedTableContent.AppID = field.NewUint32(tableName, "app_id")
	_releasedTableContent.ReleaseKvID = field.NewUint32(tableName, "release_kv_id")
	_releasedTableContent.Content = field.NewField(tableName, "content")
	_releasedTableContent.Creator = field.NewString(tableName, "creator")
	_releasedTableContent.Reviser = field.NewString(tableName, "reviser")
	_releasedTableContent.CreatedAt = field.NewTime(tableName, "created_at")
	_releasedTableContent.UpdatedAt = field.NewTime(tableName, "updated_at")

	_releasedTableContent.fillFieldMap()

	return _releasedTableContent
}

type releasedTableContent struct {
	releasedTableContentDo releasedTableContentDo

	ALL         field.Asterisk
	ID          field.Uint32
	BizID       field.Uint32
	AppID       field.Uint32
	ReleaseKvID field.Uint32
	Content     field.Field
	Creator     field.String
	Reviser     field.String
	CreatedAt   field.Time
	UpdatedAt   field.Time

	fieldMap map[string]field.Expr
}

func (r releasedTableContent) Table(newTableName string) *releasedTableContent {
	r.releasedTableContentDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r releasedTableContent) As(alias string) *releasedTableContent {
	r.releasedTableContentDo.DO = *(r.releasedTableContentDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *releasedTableContent) updateTableName(table string) *releasedTableContent {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewUint32(table, "id")
	r.BizID = field.NewUint32(table, "biz_id")
	r.AppID = field.NewUint32(table, "app_id")
	r.ReleaseKvID = field.NewUint32(table, "release_kv_id")
	r.Content = field.NewField(table, "content")
	r.Creator = field.NewString(table, "creator")
	r.Reviser = field.NewString(table, "reviser")
	r.CreatedAt = field.NewTime(table, "created_at")
	r.UpdatedAt = field.NewTime(table, "updated_at")

	r.fillFieldMap()

	return r
}

func (r *releasedTableContent) WithContext(ctx context.Context) IReleasedTableContentDo {
	return r.releasedTableContentDo.WithContext(ctx)
}

func (r releasedTableContent) TableName() string { return r.releasedTableContentDo.TableName() }

func (r releasedTableContent) Alias() string { return r.releasedTableContentDo.Alias() }

func (r releasedTableContent) Columns(cols ...field.Expr) gen.Columns {
	return r.releasedTableContentDo.Columns(cols...)
}

func (r *releasedTableContent) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *releasedTableContent) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 9)
	r.fieldMap["id"] = r.ID
	r.fieldMap["biz_id"] = r.BizID
	r.fieldMap["app_id"] = r.AppID
	r.fieldMap["release_kv_id"] = r.ReleaseKvID
	r.fieldMap["content"] = r.Content
	r.fieldMap["creator"] = r.Creator
	r.fieldMap["reviser"] = r.Reviser
	r.fieldMap["created_at"] = r.CreatedAt
	r.fieldMap["updated_at"] = r.UpdatedAt
}

func (r releasedTableContent) clone(db *gorm.DB) releasedTableContent {
	r.releasedTableContentDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r releasedTableContent) replaceDB(db *gorm.DB) releasedTableContent {
	r.releasedTableContentDo.ReplaceDB(db)
	return r
}

type releasedTableContentDo struct{ gen.DO }

type IReleasedTableContentDo interface {
	gen.SubQuery
	Debug() IReleasedTableContentDo
	WithContext(ctx context.Context) IReleasedTableContentDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IReleasedTableContentDo
	WriteDB() IReleasedTableContentDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IReleasedTableContentDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IReleasedTableContentDo
	Not(conds ...gen.Condition) IReleasedTableContentDo
	Or(conds ...gen.Condition) IReleasedTableContentDo
	Select(conds ...field.Expr) IReleasedTableContentDo
	Where(conds ...gen.Condition) IReleasedTableContentDo
	Order(conds ...field.Expr) IReleasedTableContentDo
	Distinct(cols ...field.Expr) IReleasedTableContentDo
	Omit(cols ...field.Expr) IReleasedTableContentDo
	Join(table schema.Tabler, on ...field.Expr) IReleasedTableContentDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IReleasedTableContentDo
	RightJoin(table schema.Tabler, on ...field.Expr) IReleasedTableContentDo
	Group(cols ...field.Expr) IReleasedTableContentDo
	Having(conds ...gen.Condition) IReleasedTableContentDo
	Limit(limit int) IReleasedTableContentDo
	Offset(offset int) IReleasedTableContentDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IReleasedTableContentDo
	Unscoped() IReleasedTableContentDo
	Create(values ...*table.ReleasedTableContent) error
	CreateInBatches(values []*table.ReleasedTableContent, batchSize int) error
	Save(values ...*table.ReleasedTableContent) error
	First() (*table.ReleasedTableContent, error)
	Take() (*table.ReleasedTableContent, error)
	Last() (*table.ReleasedTableContent, error)
	Find() ([]*table.ReleasedTableContent, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*table.ReleasedTableContent, err error)
	FindInBatches(result *[]*table.ReleasedTableContent, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*table.ReleasedTableContent) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IReleasedTableContentDo
	Assign(attrs ...field.AssignExpr) IReleasedTableContentDo
	Joins(fields ...field.RelationField) IReleasedTableContentDo
	Preload(fields ...field.RelationField) IReleasedTableContentDo
	FirstOrInit() (*table.ReleasedTableContent, error)
	FirstOrCreate() (*table.ReleasedTableContent, error)
	FindByPage(offset int, limit int) (result []*table.ReleasedTableContent, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IReleasedTableContentDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r releasedTableContentDo) Debug() IReleasedTableContentDo {
	return r.withDO(r.DO.Debug())
}

func (r releasedTableContentDo) WithContext(ctx context.Context) IReleasedTableContentDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r releasedTableContentDo) ReadDB() IReleasedTableContentDo {
	return r.Clauses(dbresolver.Read)
}

func (r releasedTableContentDo) WriteDB() IReleasedTableContentDo {
	return r.Clauses(dbresolver.Write)
}

func (r releasedTableContentDo) Session(config *gorm.Session) IReleasedTableContentDo {
	return r.withDO(r.DO.Session(config))
}

func (r releasedTableContentDo) Clauses(conds ...clause.Expression) IReleasedTableContentDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r releasedTableContentDo) Returning(value interface{}, columns ...string) IReleasedTableContentDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r releasedTableContentDo) Not(conds ...gen.Condition) IReleasedTableContentDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r releasedTableContentDo) Or(conds ...gen.Condition) IReleasedTableContentDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r releasedTableContentDo) Select(conds ...field.Expr) IReleasedTableContentDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r releasedTableContentDo) Where(conds ...gen.Condition) IReleasedTableContentDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r releasedTableContentDo) Order(conds ...field.Expr) IReleasedTableContentDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r releasedTableContentDo) Distinct(cols ...field.Expr) IReleasedTableContentDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r releasedTableContentDo) Omit(cols ...field.Expr) IReleasedTableContentDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r releasedTableContentDo) Join(table schema.Tabler, on ...field.Expr) IReleasedTableContentDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r releasedTableContentDo) LeftJoin(table schema.Tabler, on ...field.Expr) IReleasedTableContentDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r releasedTableContentDo) RightJoin(table schema.Tabler, on ...field.Expr) IReleasedTableContentDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r releasedTableContentDo) Group(cols ...field.Expr) IReleasedTableContentDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r releasedTableContentDo) Having(conds ...gen.Condition) IReleasedTableContentDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r releasedTableContentDo) Limit(limit int) IReleasedTableContentDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r releasedTableContentDo) Offset(offset int) IReleasedTableContentDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r releasedTableContentDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IReleasedTableContentDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r releasedTableContentDo) Unscoped() IReleasedTableContentDo {
	return r.withDO(r.DO.Unscoped())
}

func (r releasedTableContentDo) Create(values ...*table.ReleasedTableContent) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r releasedTableContentDo) CreateInBatches(values []*table.ReleasedTableContent, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r releasedTableContentDo) Save(values ...*table.ReleasedTableContent) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r releasedTableContentDo) First() (*table.ReleasedTableContent, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*table.ReleasedTableContent), nil
	}
}

func (r releasedTableContentDo) Take() (*table.ReleasedTableContent, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*table.ReleasedTableContent), nil
	}
}

func (r releasedTableContentDo) Last() (*table.ReleasedTableContent, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*table.ReleasedTableContent), nil
	}
}

func (r releasedTableContentDo) Find() ([]*table.ReleasedTableContent, error) {
	result, err := r.DO.Find()
	return result.([]*table.ReleasedTableContent), err
}

func (r releasedTableContentDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*table.ReleasedTableContent, err error) {
	buf := make([]*table.ReleasedTableContent, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r releasedTableContentDo) FindInBatches(result *[]*table.ReleasedTableContent, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r releasedTableContentDo) Attrs(attrs ...field.AssignExpr) IReleasedTableContentDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r releasedTableContentDo) Assign(attrs ...field.AssignExpr) IReleasedTableContentDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r releasedTableContentDo) Joins(fields ...field.RelationField) IReleasedTableContentDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r releasedTableContentDo) Preload(fields ...field.RelationField) IReleasedTableContentDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r releasedTableContentDo) FirstOrInit() (*table.ReleasedTableContent, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*table.ReleasedTableContent), nil
	}
}

func (r releasedTableContentDo) FirstOrCreate() (*table.ReleasedTableContent, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*table.ReleasedTableContent), nil
	}
}

func (r releasedTableContentDo) FindByPage(offset int, limit int) (result []*table.ReleasedTableContent, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r releasedTableContentDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r releasedTableContentDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r releasedTableContentDo) Delete(models ...*table.ReleasedTableContent) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *releasedTableContentDo) withDO(do gen.Dao) *releasedTableContentDo {
	r.DO = *do.(*gen.DO)
	return r
}
