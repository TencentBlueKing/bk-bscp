// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/TencentBlueKing/bk-bscp/pkg/dal/table"
)

func newProcessInstance(db *gorm.DB, opts ...gen.DOOption) processInstance {
	_processInstance := processInstance{}

	_processInstance.processInstanceDo.UseDB(db, opts...)
	_processInstance.processInstanceDo.UseModel(&table.ProcessInstance{})

	tableName := _processInstance.processInstanceDo.TableName()
	_processInstance.ALL = field.NewAsterisk(tableName)
	_processInstance.ID = field.NewUint32(tableName, "id")
	_processInstance.TenantID = field.NewString(tableName, "tenant_id")
	_processInstance.BizID = field.NewUint32(tableName, "biz_id")
	_processInstance.ProcessID = field.NewUint32(tableName, "process_id")
	_processInstance.CcProcessID = field.NewUint32(tableName, "cc_process_id")
	_processInstance.LocalInstID = field.NewString(tableName, "local_inst_id")
	_processInstance.InstID = field.NewString(tableName, "inst_id")
	_processInstance.Status = field.NewString(tableName, "status")
	_processInstance.ManagedStatus = field.NewString(tableName, "managed_status")
	_processInstance.StatusUpdatedAt = field.NewTime(tableName, "status_updated_at")
	_processInstance.Creator = field.NewString(tableName, "creator")
	_processInstance.Reviser = field.NewString(tableName, "reviser")
	_processInstance.CreatedAt = field.NewTime(tableName, "created_at")
	_processInstance.UpdatedAt = field.NewTime(tableName, "updated_at")

	_processInstance.fillFieldMap()

	return _processInstance
}

type processInstance struct {
	processInstanceDo processInstanceDo

	ALL             field.Asterisk
	ID              field.Uint32
	TenantID        field.String
	BizID           field.Uint32
	ProcessID       field.Uint32
	CcProcessID     field.Uint32
	LocalInstID     field.String
	InstID          field.String
	Status          field.String
	ManagedStatus   field.String
	StatusUpdatedAt field.Time
	Creator         field.String
	Reviser         field.String
	CreatedAt       field.Time
	UpdatedAt       field.Time

	fieldMap map[string]field.Expr
}

func (p processInstance) Table(newTableName string) *processInstance {
	p.processInstanceDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p processInstance) As(alias string) *processInstance {
	p.processInstanceDo.DO = *(p.processInstanceDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *processInstance) updateTableName(table string) *processInstance {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewUint32(table, "id")
	p.TenantID = field.NewString(table, "tenant_id")
	p.BizID = field.NewUint32(table, "biz_id")
	p.ProcessID = field.NewUint32(table, "process_id")
	p.CcProcessID = field.NewUint32(table, "cc_process_id")
	p.LocalInstID = field.NewString(table, "local_inst_id")
	p.InstID = field.NewString(table, "inst_id")
	p.Status = field.NewString(table, "status")
	p.ManagedStatus = field.NewString(table, "managed_status")
	p.StatusUpdatedAt = field.NewTime(table, "status_updated_at")
	p.Creator = field.NewString(table, "creator")
	p.Reviser = field.NewString(table, "reviser")
	p.CreatedAt = field.NewTime(table, "created_at")
	p.UpdatedAt = field.NewTime(table, "updated_at")

	p.fillFieldMap()

	return p
}

func (p *processInstance) WithContext(ctx context.Context) IProcessInstanceDo {
	return p.processInstanceDo.WithContext(ctx)
}

func (p processInstance) TableName() string { return p.processInstanceDo.TableName() }

func (p processInstance) Alias() string { return p.processInstanceDo.Alias() }

func (p processInstance) Columns(cols ...field.Expr) gen.Columns {
	return p.processInstanceDo.Columns(cols...)
}

func (p *processInstance) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *processInstance) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 14)
	p.fieldMap["id"] = p.ID
	p.fieldMap["tenant_id"] = p.TenantID
	p.fieldMap["biz_id"] = p.BizID
	p.fieldMap["process_id"] = p.ProcessID
	p.fieldMap["cc_process_id"] = p.CcProcessID
	p.fieldMap["local_inst_id"] = p.LocalInstID
	p.fieldMap["inst_id"] = p.InstID
	p.fieldMap["status"] = p.Status
	p.fieldMap["managed_status"] = p.ManagedStatus
	p.fieldMap["status_updated_at"] = p.StatusUpdatedAt
	p.fieldMap["creator"] = p.Creator
	p.fieldMap["reviser"] = p.Reviser
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["updated_at"] = p.UpdatedAt
}

func (p processInstance) clone(db *gorm.DB) processInstance {
	p.processInstanceDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p processInstance) replaceDB(db *gorm.DB) processInstance {
	p.processInstanceDo.ReplaceDB(db)
	return p
}

type processInstanceDo struct{ gen.DO }

type IProcessInstanceDo interface {
	gen.SubQuery
	Debug() IProcessInstanceDo
	WithContext(ctx context.Context) IProcessInstanceDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IProcessInstanceDo
	WriteDB() IProcessInstanceDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IProcessInstanceDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IProcessInstanceDo
	Not(conds ...gen.Condition) IProcessInstanceDo
	Or(conds ...gen.Condition) IProcessInstanceDo
	Select(conds ...field.Expr) IProcessInstanceDo
	Where(conds ...gen.Condition) IProcessInstanceDo
	Order(conds ...field.Expr) IProcessInstanceDo
	Distinct(cols ...field.Expr) IProcessInstanceDo
	Omit(cols ...field.Expr) IProcessInstanceDo
	Join(table schema.Tabler, on ...field.Expr) IProcessInstanceDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IProcessInstanceDo
	RightJoin(table schema.Tabler, on ...field.Expr) IProcessInstanceDo
	Group(cols ...field.Expr) IProcessInstanceDo
	Having(conds ...gen.Condition) IProcessInstanceDo
	Limit(limit int) IProcessInstanceDo
	Offset(offset int) IProcessInstanceDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IProcessInstanceDo
	Unscoped() IProcessInstanceDo
	Create(values ...*table.ProcessInstance) error
	CreateInBatches(values []*table.ProcessInstance, batchSize int) error
	Save(values ...*table.ProcessInstance) error
	First() (*table.ProcessInstance, error)
	Take() (*table.ProcessInstance, error)
	Last() (*table.ProcessInstance, error)
	Find() ([]*table.ProcessInstance, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*table.ProcessInstance, err error)
	FindInBatches(result *[]*table.ProcessInstance, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*table.ProcessInstance) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IProcessInstanceDo
	Assign(attrs ...field.AssignExpr) IProcessInstanceDo
	Joins(fields ...field.RelationField) IProcessInstanceDo
	Preload(fields ...field.RelationField) IProcessInstanceDo
	FirstOrInit() (*table.ProcessInstance, error)
	FirstOrCreate() (*table.ProcessInstance, error)
	FindByPage(offset int, limit int) (result []*table.ProcessInstance, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IProcessInstanceDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p processInstanceDo) Debug() IProcessInstanceDo {
	return p.withDO(p.DO.Debug())
}

func (p processInstanceDo) WithContext(ctx context.Context) IProcessInstanceDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p processInstanceDo) ReadDB() IProcessInstanceDo {
	return p.Clauses(dbresolver.Read)
}

func (p processInstanceDo) WriteDB() IProcessInstanceDo {
	return p.Clauses(dbresolver.Write)
}

func (p processInstanceDo) Session(config *gorm.Session) IProcessInstanceDo {
	return p.withDO(p.DO.Session(config))
}

func (p processInstanceDo) Clauses(conds ...clause.Expression) IProcessInstanceDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p processInstanceDo) Returning(value interface{}, columns ...string) IProcessInstanceDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p processInstanceDo) Not(conds ...gen.Condition) IProcessInstanceDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p processInstanceDo) Or(conds ...gen.Condition) IProcessInstanceDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p processInstanceDo) Select(conds ...field.Expr) IProcessInstanceDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p processInstanceDo) Where(conds ...gen.Condition) IProcessInstanceDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p processInstanceDo) Order(conds ...field.Expr) IProcessInstanceDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p processInstanceDo) Distinct(cols ...field.Expr) IProcessInstanceDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p processInstanceDo) Omit(cols ...field.Expr) IProcessInstanceDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p processInstanceDo) Join(table schema.Tabler, on ...field.Expr) IProcessInstanceDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p processInstanceDo) LeftJoin(table schema.Tabler, on ...field.Expr) IProcessInstanceDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p processInstanceDo) RightJoin(table schema.Tabler, on ...field.Expr) IProcessInstanceDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p processInstanceDo) Group(cols ...field.Expr) IProcessInstanceDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p processInstanceDo) Having(conds ...gen.Condition) IProcessInstanceDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p processInstanceDo) Limit(limit int) IProcessInstanceDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p processInstanceDo) Offset(offset int) IProcessInstanceDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p processInstanceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IProcessInstanceDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p processInstanceDo) Unscoped() IProcessInstanceDo {
	return p.withDO(p.DO.Unscoped())
}

func (p processInstanceDo) Create(values ...*table.ProcessInstance) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p processInstanceDo) CreateInBatches(values []*table.ProcessInstance, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p processInstanceDo) Save(values ...*table.ProcessInstance) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p processInstanceDo) First() (*table.ProcessInstance, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*table.ProcessInstance), nil
	}
}

func (p processInstanceDo) Take() (*table.ProcessInstance, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*table.ProcessInstance), nil
	}
}

func (p processInstanceDo) Last() (*table.ProcessInstance, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*table.ProcessInstance), nil
	}
}

func (p processInstanceDo) Find() ([]*table.ProcessInstance, error) {
	result, err := p.DO.Find()
	return result.([]*table.ProcessInstance), err
}

func (p processInstanceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*table.ProcessInstance, err error) {
	buf := make([]*table.ProcessInstance, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p processInstanceDo) FindInBatches(result *[]*table.ProcessInstance, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p processInstanceDo) Attrs(attrs ...field.AssignExpr) IProcessInstanceDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p processInstanceDo) Assign(attrs ...field.AssignExpr) IProcessInstanceDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p processInstanceDo) Joins(fields ...field.RelationField) IProcessInstanceDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p processInstanceDo) Preload(fields ...field.RelationField) IProcessInstanceDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p processInstanceDo) FirstOrInit() (*table.ProcessInstance, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*table.ProcessInstance), nil
	}
}

func (p processInstanceDo) FirstOrCreate() (*table.ProcessInstance, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*table.ProcessInstance), nil
	}
}

func (p processInstanceDo) FindByPage(offset int, limit int) (result []*table.ProcessInstance, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p processInstanceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p processInstanceDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p processInstanceDo) Delete(models ...*table.ProcessInstance) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *processInstanceDo) withDO(do gen.Dao) *processInstanceDo {
	p.DO = *do.(*gen.DO)
	return p
}
